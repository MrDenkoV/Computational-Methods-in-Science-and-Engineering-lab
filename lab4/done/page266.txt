Non-malleable code

The notion of non-malleable codes was introduced in 2010 by Dziembowski, Pietrzak, and Wichs, for relaxing the notion of error-correction and error-detection. Informally, a code is non-malleable if the message contained in a modified code-word is either the original message, or a completely unrelated value. Non-malleable codes provide a useful and meaningful security guarantee in situations where traditional error-correction and error-detection is impossible; for example, when the attacker can completely overwrite the encoded message. Although such codes do not exist if the family of "tampering functions" F is completely unrestricted, they are known to exist for many broad tampering families F.

To know the operation schema of non-malleable code, we have to have a knowledge of the basic experiment it based on. The following is the three step method of tampering experiment.

The tampering experiment can be used to model several interesting real-world settings, such as data transmitted over a noisy channel, or adversarial tampering of data stored in the memory of a physical device. Having this experimental base, we would like to build special encoding/decoding procedures formula_12, which give us some meaningful guarantees about the results of the above tampering experiment, for large and interesting families formula_13 of tampering functions. The following are several possibilities for the type of guarantees that we may hope for.

One very natural guarantee, called error-correction, would be to require that for any tampering function and any "source-message s", the tampering experiment always produces the correct decoded message formula_14.

A weaker guarantee, called error-detection, requires that the tampering-experiment always results in either the correct value formula_14 or a special symbol formula_16 indicating that tampering has been detected. This notion of error-detection is a weaker guarantee than error-correction, and achievable for larger F of tampering functions.

A non-malleable code ensures that either the tampering experiment results in a correct decoded-message formula_14, or the decoded-message formula_10 is completely independent of and unrelated to the "source-message" formula_1. In other word, the notion of non-malleability for codes is similar, in spirit, to notions of non-malleability for cryptographic primitives (such as encryption2, commitments and zero-knowledge proofs), introduced by the seminal work of Dolev, Dwork and Naor.

Compared to error correction or error detection, the "right" formalization of non-malleable codes is somewhat harder to define. Let formula_20 be a random variable for the value of the decoded-message, which results when we run the tampering experiment with source-message formula_1 and tampering-function formula_22, over the randomness of the encoding procedure. Intuitively, we wish to say that the distribution of formula_20 is independent of the encoded message formula_1. Of course, we also want to allow for the case where the tampering experiment results in formula_14 (for example, if the tampering function is identity), which clearly depends on formula_1.

Thus, we require that for every tampering-function formula_5, there exists a distribution formula_28 which outputs either concrete values formula_10 or a special same formula_30 symbol, and faithfully models the distribution of formula_20 for all formula_1 in the following sense: for every source message formula_1, the distributions of formula_20 and formula_28 are statistically close when the formula_30 symbol is interpreted as formula_1. That is, formula_28 correctly simulates the "outcome" of the tampering-experiment with a function formula_5 without knowing the source-messages formula_1, but it is allowed some ambiguity by outputting a same formula_30 symbol to indicate that the decoded-message should be the same as the source-message, without specifying what the exact value is. The fact that formula_28 depends on only formula_22 and not on formula_1, shows that the outcome of formula_20 is independent of formula_1, exempting equality.

Notice that non-malleability is a weaker guarantee than error correction/detection; the latter ensure that any change in the code-word can be corrected or at least detected by the decoding procedure, whereas the former does allow the message to be modified, but only to an unrelated value. However, when studying error correction/detection we usually restrict ourselves to limited forms of tampering which preserve some notion of distance (e.g., usually hamming distance) between the original and tampered code-word. 
For example, it is already impossible to achieve error correction/detection for the simple family of functions formula_47 which, for every constant formula_6, includes a "constant" function formula_49 that maps all inputs to formula_6. There is always some function in formula_47 that maps everything to a valid code-word formula_6. In contrast, it is trivial to construct codes that are non-malleable w.r.t formula_47, as the output of a constant function is clearly independent of its input. The prior works on non-malleable codes show that one can construct non-malleable codes for highly complex tampering function families formula_13 for which error correction/detection can not be achievable.

As one very concrete example, we study non-malleability with respect to the family of functions formula_22 which specify, for each bit of the code-word formula_3, whether to keep it as is, flip it, set it to 0, set it to 1. That is, each bit of the code-word is modified arbitrarily but independently of the value of the other bits of the code-word. We call this the “bit-wise independent tampering” family formula_57. Note that this family contains constant functions formula_47 and constant-error functions formula_59 as subsets. Therefore, as we have mentioned, error-correction and error-detection cannot be achieved w.r.t. this family. Nevertheless, the following can show an efficient non-malleable code for this powerful family.

With formula_57 we denote the family which contains all tampering functions that tamper every bit independently. Formally, this family contains all functions <math>f_i: \left\


